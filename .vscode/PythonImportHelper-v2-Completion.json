[
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "matplotlib.dates",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.dates",
        "description": "matplotlib.dates",
        "detail": "matplotlib.dates",
        "documentation": {}
    },
    {
        "label": "plotly.express",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.express",
        "description": "plotly.express",
        "detail": "plotly.express",
        "documentation": {}
    },
    {
        "label": "plotly.graph_objects",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.graph_objects",
        "description": "plotly.graph_objects",
        "detail": "plotly.graph_objects",
        "documentation": {}
    },
    {
        "label": "plotly.subplots",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.subplots",
        "description": "plotly.subplots",
        "detail": "plotly.subplots",
        "documentation": {}
    },
    {
        "label": "timeutils",
        "importPath": "aluminium_prediction",
        "description": "aluminium_prediction",
        "isExtraImport": true,
        "detail": "aluminium_prediction",
        "documentation": {}
    },
    {
        "label": "scrapping",
        "importPath": "aluminium_prediction",
        "description": "aluminium_prediction",
        "isExtraImport": true,
        "detail": "aluminium_prediction",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "kedro.pipeline",
        "description": "kedro.pipeline",
        "isExtraImport": true,
        "detail": "kedro.pipeline",
        "documentation": {}
    },
    {
        "label": "pipeline",
        "importPath": "kedro.pipeline",
        "description": "kedro.pipeline",
        "isExtraImport": true,
        "detail": "kedro.pipeline",
        "documentation": {}
    },
    {
        "label": "node",
        "importPath": "kedro.pipeline",
        "description": "kedro.pipeline",
        "isExtraImport": true,
        "detail": "kedro.pipeline",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "kedro.pipeline",
        "description": "kedro.pipeline",
        "isExtraImport": true,
        "detail": "kedro.pipeline",
        "documentation": {}
    },
    {
        "label": "pipeline",
        "importPath": "kedro.pipeline",
        "description": "kedro.pipeline",
        "isExtraImport": true,
        "detail": "kedro.pipeline",
        "documentation": {}
    },
    {
        "label": "node",
        "importPath": "kedro.pipeline",
        "description": "kedro.pipeline",
        "isExtraImport": true,
        "detail": "kedro.pipeline",
        "documentation": {}
    },
    {
        "label": "westmetall_download",
        "importPath": "aluminium_prediction.pipelines.aquisition.nodes",
        "description": "aluminium_prediction.pipelines.aquisition.nodes",
        "isExtraImport": true,
        "detail": "aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "westmetall_actualize",
        "importPath": "aluminium_prediction.pipelines.aquisition.nodes",
        "description": "aluminium_prediction.pipelines.aquisition.nodes",
        "isExtraImport": true,
        "detail": "aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "investing_download",
        "importPath": "aluminium_prediction.pipelines.aquisition.nodes",
        "description": "aluminium_prediction.pipelines.aquisition.nodes",
        "isExtraImport": true,
        "detail": "aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "investing_actualize",
        "importPath": "aluminium_prediction.pipelines.aquisition.nodes",
        "description": "aluminium_prediction.pipelines.aquisition.nodes",
        "isExtraImport": true,
        "detail": "aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "investing_correct_volumes",
        "importPath": "aluminium_prediction.pipelines.aquisition.nodes",
        "description": "aluminium_prediction.pipelines.aquisition.nodes",
        "isExtraImport": true,
        "detail": "aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "visualize_aluminium_datasets",
        "importPath": "aluminium_prediction.pipelines.aquisition.nodes",
        "description": "aluminium_prediction.pipelines.aquisition.nodes",
        "isExtraImport": true,
        "detail": "aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "plotly_aluminium_datasets",
        "importPath": "aluminium_prediction.pipelines.aquisition.nodes",
        "description": "aluminium_prediction.pipelines.aquisition.nodes",
        "isExtraImport": true,
        "detail": "aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "plotly_aluminium_prices",
        "importPath": "aluminium_prediction.pipelines.aquisition.nodes",
        "description": "aluminium_prediction.pipelines.aquisition.nodes",
        "isExtraImport": true,
        "detail": "aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "scipy.signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.signal",
        "description": "scipy.signal",
        "detail": "scipy.signal",
        "documentation": {}
    },
    {
        "label": "statsmodels",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "statsmodels",
        "description": "statsmodels",
        "detail": "statsmodels",
        "documentation": {}
    },
    {
        "label": "statsmodels.tsa",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "statsmodels.tsa",
        "description": "statsmodels.tsa",
        "detail": "statsmodels.tsa",
        "documentation": {}
    },
    {
        "label": "statsmodels.tsa.stattools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "statsmodels.tsa.stattools",
        "description": "statsmodels.tsa.stattools",
        "detail": "statsmodels.tsa.stattools",
        "documentation": {}
    },
    {
        "label": "statsmodels.tools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "statsmodels.tools",
        "description": "statsmodels.tools",
        "detail": "statsmodels.tools",
        "documentation": {}
    },
    {
        "label": "InterpolationWarning",
        "importPath": "statsmodels.tools.sm_exceptions",
        "description": "statsmodels.tools.sm_exceptions",
        "isExtraImport": true,
        "detail": "statsmodels.tools.sm_exceptions",
        "documentation": {}
    },
    {
        "label": "InterpolationWarning",
        "importPath": "statsmodels.tools.sm_exceptions",
        "description": "statsmodels.tools.sm_exceptions",
        "isExtraImport": true,
        "detail": "statsmodels.tools.sm_exceptions",
        "documentation": {}
    },
    {
        "label": "emd",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "emd",
        "description": "emd",
        "detail": "emd",
        "documentation": {}
    },
    {
        "label": "copent",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copent",
        "description": "copent",
        "detail": "copent",
        "documentation": {}
    },
    {
        "label": "aluminium_prediction.stationarity",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aluminium_prediction.stationarity",
        "description": "aluminium_prediction.stationarity",
        "detail": "aluminium_prediction.stationarity",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "find_pipelines",
        "importPath": "kedro.framework.project",
        "description": "kedro.framework.project",
        "isExtraImport": true,
        "detail": "kedro.framework.project",
        "documentation": {}
    },
    {
        "label": "create_pipeline",
        "importPath": "aluminium_prediction.pipelines.aquisition.pipeline",
        "description": "aluminium_prediction.pipelines.aquisition.pipeline",
        "isExtraImport": true,
        "detail": "aluminium_prediction.pipelines.aquisition.pipeline",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "Service",
        "importPath": "selenium.webdriver.chrome.service",
        "description": "selenium.webdriver.chrome.service",
        "isExtraImport": true,
        "detail": "selenium.webdriver.chrome.service",
        "documentation": {}
    },
    {
        "label": "ChromeDriverManager",
        "importPath": "webdriver_manager.chrome",
        "description": "webdriver_manager.chrome",
        "isExtraImport": true,
        "detail": "webdriver_manager.chrome",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "HTTPStatus",
        "importPath": "http",
        "description": "http",
        "isExtraImport": true,
        "detail": "http",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "importPath": "requests.exceptions",
        "description": "requests.exceptions",
        "isExtraImport": true,
        "detail": "requests.exceptions",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "SQLiteStore",
        "importPath": "kedro_viz.integrations.kedro.sqlite_store",
        "description": "kedro_viz.integrations.kedro.sqlite_store",
        "isExtraImport": true,
        "detail": "kedro_viz.integrations.kedro.sqlite_store",
        "documentation": {}
    },
    {
        "label": "OmegaConfigLoader",
        "importPath": "kedro.config",
        "description": "kedro.config",
        "isExtraImport": true,
        "detail": "kedro.config",
        "documentation": {}
    },
    {
        "label": "OmegaConfigLoader",
        "importPath": "kedro.config",
        "description": "kedro.config",
        "isExtraImport": true,
        "detail": "kedro.config",
        "documentation": {}
    },
    {
        "label": "AbstractDataset",
        "importPath": "kedro.io",
        "description": "kedro.io",
        "isExtraImport": true,
        "detail": "kedro.io",
        "documentation": {}
    },
    {
        "label": "DataCatalog",
        "importPath": "kedro.io",
        "description": "kedro.io",
        "isExtraImport": true,
        "detail": "kedro.io",
        "documentation": {}
    },
    {
        "label": "get_filepath_str",
        "importPath": "kedro.io.core",
        "description": "kedro.io.core",
        "isExtraImport": true,
        "detail": "kedro.io.core",
        "documentation": {}
    },
    {
        "label": "DatasetError",
        "importPath": "kedro.io.core",
        "description": "kedro.io.core",
        "isExtraImport": true,
        "detail": "kedro.io.core",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "SequentialRunner",
        "importPath": "kedro.runner",
        "description": "kedro.runner",
        "isExtraImport": true,
        "detail": "kedro.runner",
        "documentation": {}
    },
    {
        "label": "create_pipeline",
        "importPath": "aluminium_prediction.pipelines.data_science",
        "description": "aluminium_prediction.pipelines.data_science",
        "isExtraImport": true,
        "detail": "aluminium_prediction.pipelines.data_science",
        "documentation": {}
    },
    {
        "label": "split_data",
        "importPath": "aluminium_prediction.pipelines.data_science.nodes",
        "description": "aluminium_prediction.pipelines.data_science.nodes",
        "isExtraImport": true,
        "detail": "aluminium_prediction.pipelines.data_science.nodes",
        "documentation": {}
    },
    {
        "label": "KedroContext",
        "importPath": "kedro.framework.context",
        "description": "kedro.framework.context",
        "isExtraImport": true,
        "detail": "kedro.framework.context",
        "documentation": {}
    },
    {
        "label": "_create_hook_manager",
        "importPath": "kedro.framework.hooks",
        "description": "kedro.framework.hooks",
        "isExtraImport": true,
        "detail": "kedro.framework.hooks",
        "documentation": {}
    },
    {
        "label": "#df",
        "kind": 5,
        "importPath": "data.01_raw.show_dataframe",
        "description": "data.01_raw.show_dataframe",
        "peekOfCode": "#df = pd.read_csv('investing_dataset.csv',sep=';')\ndf = pd.read_csv('westmetall_dataset.csv',sep=';')\n# Convert entire data frame as string and print\nprint(df.to_string())",
        "detail": "data.01_raw.show_dataframe",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "data.01_raw.show_dataframe",
        "description": "data.01_raw.show_dataframe",
        "peekOfCode": "df = pd.read_csv('westmetall_dataset.csv',sep=';')\n# Convert entire data frame as string and print\nprint(df.to_string())",
        "detail": "data.01_raw.show_dataframe",
        "documentation": {}
    },
    {
        "label": "westmetall_download",
        "kind": 2,
        "importPath": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "description": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "peekOfCode": "def westmetall_download(page_url: str = 'https://www.westmetall.com/en/markdaten.php?action=table&field=LME_Al_cash',\n                        all: bool = False) -> pd.DataFrame:\n    \"\"\"_summary_\n    NOTE: This function can be used to get whole dataset from the url (data are set statically in the html).\n    Args:\n        page_url (str, optional): _description_. Defaults to 'https://www.westmetall.com/en/markdaten.php?action=table&field=LME_Al_cash'.\n        all (bool, optional): _description_. Defaults to False.\n    Returns:\n        _type_: _description_\n    \"\"\"",
        "detail": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "westmetall_actualize",
        "kind": 2,
        "importPath": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "description": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "peekOfCode": "def westmetall_actualize(dataset: pd.DataFrame,\n                         update: pd.DataFrame) -> pd.DataFrame:\n    # convert to proper datetime object\n    #dataset['Date'] = dataset['Date'].apply(lambda x: datetime.date( *map(int,x.split('-')) ))\n    dataset['Date'] = timeutils.convert_to_datetime(dataset['Date'])\n    if type(dataset['Date'][0]) != type(update['Date'][0]):\n        print( type(dataset['Date'][0]) )\n        print( type(update['Date'][0]) )\n        raise ValueError\n    new_dataset = pd.concat([dataset, update])",
        "detail": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "dataset_actualize",
        "kind": 2,
        "importPath": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "description": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "peekOfCode": "def dataset_actualize(dataset: pd.DataFrame,\n                      update: pd.DataFrame) -> pd.DataFrame:\n    # convert to proper datetime object (NOTE: while saving to csv date is converted to str)\n    dataset['Date'] = timeutils.convert_to_datetime(dataset['Date'])\n    if type(dataset['Date'][0]) != type(update['Date'][0]):\n        print( type(dataset['Date'][0]) )\n        print( type(update['Date'][0]) )\n        raise ValueError\n    new_dataset = pd.concat([dataset, update])\n    new_dataset = new_dataset.sort_values('Date')",
        "detail": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "metals_api_convert_price",
        "kind": 2,
        "importPath": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "description": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "peekOfCode": "def metals_api_convert_price(price: float) -> float:\n    \"\"\"_summary_\n    This function converts price in USD per troy ounce to normal units...\n    Args:\n        price (float): _description_\n    Returns:\n        _type_: _description_\n    \"\"\"\n    return (1.0/price)/31.1035*1000000\ndef metalsapi_download():",
        "detail": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "metalsapi_download",
        "kind": 2,
        "importPath": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "description": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "peekOfCode": "def metalsapi_download():\n    # TODO\n    return None\ndef investing_download(page_url: str = 'https://www.investing.com/commodities/aluminum-historical-data'):\n    \"\"\"_summary_\n    NOTE: This function cannot be used to download whole dataset from the url.\n    Args:\n        page_url (str, optional): _description_. Defaults to 'https://www.investing.com/commodities/aluminum-historical-data'.\n    Returns:\n        _type_: _description_",
        "detail": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "investing_download",
        "kind": 2,
        "importPath": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "description": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "peekOfCode": "def investing_download(page_url: str = 'https://www.investing.com/commodities/aluminum-historical-data'):\n    \"\"\"_summary_\n    NOTE: This function cannot be used to download whole dataset from the url.\n    Args:\n        page_url (str, optional): _description_. Defaults to 'https://www.investing.com/commodities/aluminum-historical-data'.\n    Returns:\n        _type_: _description_\n    \"\"\"\n    driver = scrapping.get_selenium_driver()\n    driver.get(page_url)",
        "detail": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "investing_actualize",
        "kind": 2,
        "importPath": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "description": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "peekOfCode": "def investing_actualize(dataset: pd.DataFrame,\n                         update: pd.DataFrame) -> pd.DataFrame:\n    # convert to proper datetime object\n    #dataset['Date'] = dataset['Date'].apply(lambda x: datetime.date( *map(int,x.split('-')) ))\n    dataset['Date'] = timeutils.convert_to_datetime(dataset['Date'])\n    print(dataset.head())\n    print(update.head())\n    print( type(dataset['Date'][0]) )\n    print( type(update['Date'][0]) )\n    print()",
        "detail": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "investing_correct_volumes",
        "kind": 2,
        "importPath": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "description": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "peekOfCode": "def investing_correct_volumes(dataset: pd.DataFrame) -> pd.DataFrame:\n    dataset['Date'] = timeutils.convert_to_datetime(dataset['Date'])\n    idx = (dataset['Date'] > datetime.date(2019, 9, 20)) & (dataset['Date'] < datetime.date(2020, 7, 4))\n    dataset['LME vol'] = dataset['LME vol']*idx.astype(float)*0.1\n    return dataset\ndef visualize_aluminium_datasets(westmetall_dataset: pd.DataFrame, \n                                 investing_dataset: pd.DataFrame):\n    westmetall_dataset['Date'] = timeutils.convert_to_datetime(westmetall_dataset['Date'])\n    investing_dataset['Date'] = timeutils.convert_to_datetime(investing_dataset['Date'])\n    fig, axes = plt.subplots(ncols=1, nrows=2, sharex=True, figsize=[20.,14.])",
        "detail": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "visualize_aluminium_datasets",
        "kind": 2,
        "importPath": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "description": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "peekOfCode": "def visualize_aluminium_datasets(westmetall_dataset: pd.DataFrame, \n                                 investing_dataset: pd.DataFrame):\n    westmetall_dataset['Date'] = timeutils.convert_to_datetime(westmetall_dataset['Date'])\n    investing_dataset['Date'] = timeutils.convert_to_datetime(investing_dataset['Date'])\n    fig, axes = plt.subplots(ncols=1, nrows=2, sharex=True, figsize=[20.,14.])\n    ax1, ax2 = axes.ravel()\n    fig.suptitle('Aluminium LME 3-month prices')\n    # LME price plot\n    ax1.grid(True)\n    ax1.xaxis.set_major_locator(matplotlib.dates.YearLocator())",
        "detail": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "plotly_aluminium_datasets",
        "kind": 2,
        "importPath": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "description": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "peekOfCode": "def plotly_aluminium_datasets( westmetall_dataset: pd.DataFrame,\n                               investing_dataset: pd.DataFrame,\n                               metalsapi_dataset: pd.DataFrame ):\n    \"\"\"_summary_\n    ```\n    poetry run kedro run --from-nodes \"plotly_aluminium_node\"\n    ```\n    Args:\n        westmetall_dataset (pd.DataFrame): _description_\n        investing_dataset (pd.DataFrame): _description_",
        "detail": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "plotly_aluminium_prices",
        "kind": 2,
        "importPath": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "description": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "peekOfCode": "def plotly_aluminium_prices( westmetall_dataset : pd.DataFrame,\n                               investing_dataset: pd.DataFrame,\n                               metalsapi_dataset: pd.DataFrame ):\n    \"\"\"_summary_\n    ```\n    poetry run kedro run --from-nodes \"plotly_aluminium_node\"\n    ```\n    Args:\n        westmetall_dataset (pd.DataFrame): _description_\n        investing_dataset (pd.DataFrame): _description_",
        "detail": "src.aluminium_prediction.pipelines.aquisition.nodes",
        "documentation": {}
    },
    {
        "label": "create_pipeline",
        "kind": 2,
        "importPath": "src.aluminium_prediction.pipelines.aquisition.pipeline",
        "description": "src.aluminium_prediction.pipelines.aquisition.pipeline",
        "peekOfCode": "def create_pipeline(**kwargs) -> Pipeline:\n    return pipeline(\n        [\n            node(\n                westmetall_download,\n                inputs=None,\n                outputs=\"westmetall_download\",\n                name=\"westmetall_download_node\",\n            ),\n            node(",
        "detail": "src.aluminium_prediction.pipelines.aquisition.pipeline",
        "documentation": {}
    },
    {
        "label": "cross_correlation",
        "kind": 2,
        "importPath": "src.aluminium_prediction.causality",
        "description": "src.aluminium_prediction.causality",
        "peekOfCode": "def cross_correlation(p, q, stationarize=False):\n    \"\"\"\n    source: https://www.datainsightonline.com/post/cross-correlation-with-two-time-series-in-python#google_vignette\n    \"\"\"\n    if stationarize is True:\n        p = aluminium_prediction.stationarity.remove_residual_emd(p, n=1)\n        q = aluminium_prediction.stationarity.remove_residual_emd(q, n=1)\n    p = (p - np.mean(p)) / (np.std(p) * len(p))\n    q = (q - np.mean(q)) / (np.std(q))  \n    lags = scipy.signal.correlation_lags(len(p), len(q))",
        "detail": "src.aluminium_prediction.causality",
        "documentation": {}
    },
    {
        "label": "cross_correlation_plot",
        "kind": 2,
        "importPath": "src.aluminium_prediction.causality",
        "description": "src.aluminium_prediction.causality",
        "peekOfCode": "def cross_correlation_plot(lags, ccf_values, title='', show=True, fig=None, ax=None):\n    \"\"\"\n    source: https://www.datainsightonline.com/post/cross-correlation-with-two-time-series-in-python#google_vignette\n    \"\"\"\n    if (fig is None) or (ax is None):\n        fig, ax = plt.subplots(figsize=(9, 6))\n    ax.plot(lags, ccf_values)\n    ax.axhline(-2/np.sqrt(23), color='red', label='5% confidence interval')\n    ax.axhline(2/np.sqrt(23), color='red')\n    ax.axvline(x = 0, color = 'black', lw = 1)",
        "detail": "src.aluminium_prediction.causality",
        "documentation": {}
    },
    {
        "label": "transfer_entropy",
        "kind": 2,
        "importPath": "src.aluminium_prediction.causality",
        "description": "src.aluminium_prediction.causality",
        "peekOfCode": "def transfer_entropy(p, q, nlags=30, stationarize=False):\n    \"\"\"_summary_\n    Args:\n        p (_type_): _description_\n        q (_type_): _description_\n        nlags (int, optional): _description_. Defaults to 30.\n        stationarize (bool, optional): _description_. Defaults to False.\n    Returns:\n        _type_: _description_\n    source: https://www.kaggle.com/code/singh2299/transfer-entropy-causal",
        "detail": "src.aluminium_prediction.causality",
        "documentation": {}
    },
    {
        "label": "register_pipelines",
        "kind": 2,
        "importPath": "src.aluminium_prediction.pipeline_registry",
        "description": "src.aluminium_prediction.pipeline_registry",
        "peekOfCode": "def register_pipelines() -> Dict[str, Pipeline]:\n    \"\"\"Register the project's pipelines.\n    Returns:\n        A mapping from pipeline names to ``Pipeline`` objects.\n    \"\"\"\n    pipelines = find_pipelines()\n    pipelines[\"__default__\"] = sum(pipelines.values())\n    pipelines[\"aquisition\"] = aquisition_pipeline()\n    return pipelines",
        "detail": "src.aluminium_prediction.pipeline_registry",
        "documentation": {}
    },
    {
        "label": "get_selenium_driver",
        "kind": 2,
        "importPath": "src.aluminium_prediction.scrapping",
        "description": "src.aluminium_prediction.scrapping",
        "peekOfCode": "def get_selenium_driver():\n    options = webdriver.ChromeOptions()\n    options.add_argument(\"--headless=new\") # run browser in headless mode\n    driver = webdriver.Chrome(service=ChromeService( ChromeDriverManager().install() ),\n                              options=options) \n    return driver\ndef request_data(url, retries=5):\n    response = None\n    for n in range(retries):\n        try:",
        "detail": "src.aluminium_prediction.scrapping",
        "documentation": {}
    },
    {
        "label": "request_data",
        "kind": 2,
        "importPath": "src.aluminium_prediction.scrapping",
        "description": "src.aluminium_prediction.scrapping",
        "peekOfCode": "def request_data(url, retries=5):\n    response = None\n    for n in range(retries):\n        try:\n            response = requests.get(url)\n            response.raise_for_status()\n            break\n        except HTTPError as exc:\n            code = exc.response.status_code\n            if code in retry_codes:",
        "detail": "src.aluminium_prediction.scrapping",
        "documentation": {}
    },
    {
        "label": "retry_codes",
        "kind": 5,
        "importPath": "src.aluminium_prediction.scrapping",
        "description": "src.aluminium_prediction.scrapping",
        "peekOfCode": "retry_codes = [\n    HTTPStatus.TOO_MANY_REQUESTS,\n    HTTPStatus.INTERNAL_SERVER_ERROR,\n    HTTPStatus.BAD_GATEWAY,\n    HTTPStatus.SERVICE_UNAVAILABLE,\n    HTTPStatus.GATEWAY_TIMEOUT,\n]\ndef get_selenium_driver():\n    options = webdriver.ChromeOptions()\n    options.add_argument(\"--headless=new\") # run browser in headless mode",
        "detail": "src.aluminium_prediction.scrapping",
        "documentation": {}
    },
    {
        "label": "SESSION_STORE_CLASS",
        "kind": 5,
        "importPath": "src.aluminium_prediction.settings",
        "description": "src.aluminium_prediction.settings",
        "peekOfCode": "SESSION_STORE_CLASS = SQLiteStore\n# Keyword arguments to pass to the `SESSION_STORE_CLASS` constructor.\nSESSION_STORE_ARGS = {\"path\": str(Path(__file__).parents[2])}\n# Directory that holds configuration.\n# CONF_SOURCE = \"conf\"\n# Class that manages how configuration is loaded.\nfrom kedro.config import OmegaConfigLoader  # noqa: E402\nCONFIG_LOADER_CLASS = OmegaConfigLoader\n# Keyword arguments to pass to the `CONFIG_LOADER_CLASS` constructor.\nCONFIG_LOADER_ARGS = {",
        "detail": "src.aluminium_prediction.settings",
        "documentation": {}
    },
    {
        "label": "SESSION_STORE_ARGS",
        "kind": 5,
        "importPath": "src.aluminium_prediction.settings",
        "description": "src.aluminium_prediction.settings",
        "peekOfCode": "SESSION_STORE_ARGS = {\"path\": str(Path(__file__).parents[2])}\n# Directory that holds configuration.\n# CONF_SOURCE = \"conf\"\n# Class that manages how configuration is loaded.\nfrom kedro.config import OmegaConfigLoader  # noqa: E402\nCONFIG_LOADER_CLASS = OmegaConfigLoader\n# Keyword arguments to pass to the `CONFIG_LOADER_CLASS` constructor.\nCONFIG_LOADER_ARGS = {\n      \"base_env\": \"base\",\n      \"default_run_env\": \"local\",",
        "detail": "src.aluminium_prediction.settings",
        "documentation": {}
    },
    {
        "label": "CONFIG_LOADER_CLASS",
        "kind": 5,
        "importPath": "src.aluminium_prediction.settings",
        "description": "src.aluminium_prediction.settings",
        "peekOfCode": "CONFIG_LOADER_CLASS = OmegaConfigLoader\n# Keyword arguments to pass to the `CONFIG_LOADER_CLASS` constructor.\nCONFIG_LOADER_ARGS = {\n      \"base_env\": \"base\",\n      \"default_run_env\": \"local\",\n#       \"config_patterns\": {\n#           \"spark\" : [\"spark*/\"],\n#           \"parameters\": [\"parameters*\", \"parameters*/**\", \"**/parameters*\"],\n#       }\n}",
        "detail": "src.aluminium_prediction.settings",
        "documentation": {}
    },
    {
        "label": "CONFIG_LOADER_ARGS",
        "kind": 5,
        "importPath": "src.aluminium_prediction.settings",
        "description": "src.aluminium_prediction.settings",
        "peekOfCode": "CONFIG_LOADER_ARGS = {\n      \"base_env\": \"base\",\n      \"default_run_env\": \"local\",\n#       \"config_patterns\": {\n#           \"spark\" : [\"spark*/\"],\n#           \"parameters\": [\"parameters*\", \"parameters*/**\", \"**/parameters*\"],\n#       }\n}\n# Class that manages Kedro's library components.\n# from kedro.framework.context import KedroContext",
        "detail": "src.aluminium_prediction.settings",
        "documentation": {}
    },
    {
        "label": "adf_test",
        "kind": 2,
        "importPath": "src.aluminium_prediction.stationarity",
        "description": "src.aluminium_prediction.stationarity",
        "peekOfCode": "def adf_test(timeseries, pvalue=0.05, truefalse=True):\n  \"\"\"\n  See https://www.statsmodels.org/dev/generated/statsmodels.tsa.stattools.adfuller.html.\n  \"\"\"\n  # TODO: Add filtering of InterpolationWarning\n  test_result = statsmodels.tsa.stattools.adfuller(timeseries, autolag='AIC')\n  test_pvalue = test_result[1]\n  if truefalse is True:\n    return test_pvalue < pvalue\n  else:",
        "detail": "src.aluminium_prediction.stationarity",
        "documentation": {}
    },
    {
        "label": "kpss_test",
        "kind": 2,
        "importPath": "src.aluminium_prediction.stationarity",
        "description": "src.aluminium_prediction.stationarity",
        "peekOfCode": "def kpss_test(timeseries, pvalue=0.05, truefalse=True):\n  with warnings.catch_warnings(record=True) as w:\n    warnings.filterwarnings(action='always',\n                            category=InterpolationWarning)\n    test_result = statsmodels.tsa.stattools.kpss(timeseries, regression=\"c\", nlags=\"auto\")\n    test_pvalue = test_result[1]\n    if   (len(w) == 1) and ('p-value is greater' in str(w[-1].message)):\n       print(str(w[-1].message))\n    elif (len(w) == 1) and ('p-value is smaller' in str(w[-1].message)):\n       pass",
        "detail": "src.aluminium_prediction.stationarity",
        "documentation": {}
    },
    {
        "label": "stationarity_test",
        "kind": 2,
        "importPath": "src.aluminium_prediction.stationarity",
        "description": "src.aluminium_prediction.stationarity",
        "peekOfCode": "def stationarity_test(timeseries, pvalue=0.05, verbose=1):\n  adf_result = adf_test(timeseries, pvalue=pvalue, truefalse=True)\n  kpss_result = kpss_test(timeseries, pvalue=pvalue, truefalse=True)\n  if verbose > 0:\n    print('Stationarity (ADF test): ', adf_result)\n    print('Stationarity (KPSS test):', kpss_result)\n  return adf_result and kpss_result\ndef remove_residual_emd(signal, n=1):\n  imf_opts = {'sd_thresh': 0.05}\n  imfs = emd.sift.sift(signal,imf_opts=imf_opts)",
        "detail": "src.aluminium_prediction.stationarity",
        "documentation": {}
    },
    {
        "label": "remove_residual_emd",
        "kind": 2,
        "importPath": "src.aluminium_prediction.stationarity",
        "description": "src.aluminium_prediction.stationarity",
        "peekOfCode": "def remove_residual_emd(signal, n=1):\n  imf_opts = {'sd_thresh': 0.05}\n  imfs = emd.sift.sift(signal,imf_opts=imf_opts)\n  if n > imfs.shape[1]:\n    n = imfs.shape[1]\n  return signal - imfs[:,-n:].sum(axis=1)",
        "detail": "src.aluminium_prediction.stationarity",
        "documentation": {}
    },
    {
        "label": "convert_to_datetime",
        "kind": 2,
        "importPath": "src.aluminium_prediction.timeutils",
        "description": "src.aluminium_prediction.timeutils",
        "peekOfCode": "def convert_to_datetime(column):\n    return column.apply(lambda x: datetime.date( *map(int,str(x).split('-')) ))\ndef last_day_of_month(any_day):\n    # The day 28 exists in every month. 4 days later, it's always next month\n    next_month = any_day.replace(day=28) + datetime.timedelta(days=4)\n    # subtracting the number of the current day brings us back one month\n    return next_month - datetime.timedelta(days=next_month.day)",
        "detail": "src.aluminium_prediction.timeutils",
        "documentation": {}
    },
    {
        "label": "last_day_of_month",
        "kind": 2,
        "importPath": "src.aluminium_prediction.timeutils",
        "description": "src.aluminium_prediction.timeutils",
        "peekOfCode": "def last_day_of_month(any_day):\n    # The day 28 exists in every month. 4 days later, it's always next month\n    next_month = any_day.replace(day=28) + datetime.timedelta(days=4)\n    # subtracting the number of the current day brings us back one month\n    return next_month - datetime.timedelta(days=next_month.day)",
        "detail": "src.aluminium_prediction.timeutils",
        "documentation": {}
    },
    {
        "label": "month_dict",
        "kind": 5,
        "importPath": "src.aluminium_prediction.timeutils",
        "description": "src.aluminium_prediction.timeutils",
        "peekOfCode": "month_dict = { 'January'  : 1,\n               'February' : 2,\n               'March'    : 3,\n               'April'    : 4,\n               'May'      : 5,\n               'June'     : 6,\n               'July'     : 7,\n               'August'   : 8,\n               'September': 9,\n               'October'  : 10,",
        "detail": "src.aluminium_prediction.timeutils",
        "documentation": {}
    },
    {
        "label": "PlotlyHTMLDataset",
        "kind": 6,
        "importPath": "src.datasets",
        "description": "src.datasets",
        "peekOfCode": "class PlotlyHTMLDataset(AbstractDataset):\n    def __init__(self, filepath):\n        self._filepath = filepath\n    def _load(self) -> NoReturn:\n        raise DatasetError(f\"Loading not supported for '{self.__class__.__name__}'\")\n    def _save(self, fig) -> None:\n        fname = self._filepath\n        if not '.html' in fname:\n            fname += '.html'\n        fig.write_html(fname)",
        "detail": "src.datasets",
        "documentation": {}
    },
    {
        "label": "dummy_data",
        "kind": 2,
        "importPath": "tests.pipelines.data_science.test_pipeline",
        "description": "tests.pipelines.data_science.test_pipeline",
        "peekOfCode": "def dummy_data():\n    return pd.DataFrame(\n        {\n            \"engines\": [1, 2, 3],\n            \"crew\": [4, 5, 6],\n            \"passenger_capacity\": [5, 6, 7],\n            \"price\": [120, 290, 30],\n        }\n    )\n@pytest.fixture",
        "detail": "tests.pipelines.data_science.test_pipeline",
        "documentation": {}
    },
    {
        "label": "dummy_parameters",
        "kind": 2,
        "importPath": "tests.pipelines.data_science.test_pipeline",
        "description": "tests.pipelines.data_science.test_pipeline",
        "peekOfCode": "def dummy_parameters():\n    parameters = {\n        \"model_options\": {\n            \"test_size\": 0.2,\n            \"random_state\": 3,\n            \"features\": [\"engines\", \"passenger_capacity\", \"crew\"],\n        }\n    }\n    return parameters\ndef test_split_data(dummy_data, dummy_parameters):",
        "detail": "tests.pipelines.data_science.test_pipeline",
        "documentation": {}
    },
    {
        "label": "test_split_data",
        "kind": 2,
        "importPath": "tests.pipelines.data_science.test_pipeline",
        "description": "tests.pipelines.data_science.test_pipeline",
        "peekOfCode": "def test_split_data(dummy_data, dummy_parameters):\n    X_train, X_test, y_train, y_test = split_data(\n        dummy_data, dummy_parameters[\"model_options\"]\n    )\n    assert len(X_train) == 2\n    assert len(y_train) == 2\n    assert len(X_test) == 1\n    assert len(y_test) == 1\ndef test_split_data_missing_price(dummy_data, dummy_parameters):\n    dummy_data_missing_price = dummy_data.drop(columns=\"price\")",
        "detail": "tests.pipelines.data_science.test_pipeline",
        "documentation": {}
    },
    {
        "label": "test_split_data_missing_price",
        "kind": 2,
        "importPath": "tests.pipelines.data_science.test_pipeline",
        "description": "tests.pipelines.data_science.test_pipeline",
        "peekOfCode": "def test_split_data_missing_price(dummy_data, dummy_parameters):\n    dummy_data_missing_price = dummy_data.drop(columns=\"price\")\n    with pytest.raises(KeyError) as e_info:\n        X_train, X_test, y_train, y_test = split_data(dummy_data_missing_price, dummy_parameters[\"model_options\"])\n    assert \"price\" in str(e_info.value)\ndef test_data_science_pipeline(caplog, dummy_data, dummy_parameters):\n    pipeline = (\n        create_ds_pipeline()\n        .from_nodes(\"split_data_node\")\n        .to_nodes(\"evaluate_model_node\")",
        "detail": "tests.pipelines.data_science.test_pipeline",
        "documentation": {}
    },
    {
        "label": "test_data_science_pipeline",
        "kind": 2,
        "importPath": "tests.pipelines.data_science.test_pipeline",
        "description": "tests.pipelines.data_science.test_pipeline",
        "peekOfCode": "def test_data_science_pipeline(caplog, dummy_data, dummy_parameters):\n    pipeline = (\n        create_ds_pipeline()\n        .from_nodes(\"split_data_node\")\n        .to_nodes(\"evaluate_model_node\")\n    )\n    catalog = DataCatalog()\n    catalog.add_feed_dict(\n        {\n            \"model_input_table\" : dummy_data,",
        "detail": "tests.pipelines.data_science.test_pipeline",
        "documentation": {}
    },
    {
        "label": "TestProjectContext",
        "kind": 6,
        "importPath": "tests.test_run",
        "description": "tests.test_run",
        "peekOfCode": "class TestProjectContext:\n    def test_project_path(self, project_context):\n        assert project_context.project_path == Path.cwd()",
        "detail": "tests.test_run",
        "documentation": {}
    },
    {
        "label": "config_loader",
        "kind": 2,
        "importPath": "tests.test_run",
        "description": "tests.test_run",
        "peekOfCode": "def config_loader():\n    return OmegaConfigLoader(conf_source=str(Path.cwd()))\n@pytest.fixture\ndef project_context(config_loader):\n    return KedroContext(\n        package_name=\"aluminium_prediction\",\n        project_path=Path.cwd(),\n        config_loader=config_loader,\n        hook_manager=_create_hook_manager(),\n    )",
        "detail": "tests.test_run",
        "documentation": {}
    },
    {
        "label": "project_context",
        "kind": 2,
        "importPath": "tests.test_run",
        "description": "tests.test_run",
        "peekOfCode": "def project_context(config_loader):\n    return KedroContext(\n        package_name=\"aluminium_prediction\",\n        project_path=Path.cwd(),\n        config_loader=config_loader,\n        hook_manager=_create_hook_manager(),\n    )\n# The tests below are here for the demonstration purpose\n# and should be replaced with the ones testing the project\n# functionality",
        "detail": "tests.test_run",
        "documentation": {}
    }
]